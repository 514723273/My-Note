软件开发的一个不变真理：变化。

不管当初软件设计得多好，一阵子之后，总是需要成长与改变，否则软件就会”死亡“。

## 设计原则

1. 找出应用中可能需要变化之处，把它们独立封装，以便以后可以轻易地扩充此部分，而不影响其他不变的部分；
2. 针对接口编程，而不是针对实现编程；
3. 多用组合（有一个），少用继承（是一个）；

## 0. 设计模式入门

模拟鸭子游戏：SimUDuck🦆

- 现有设计：鸭子超类（Superclass），并让各种鸭子继承此超类；
- 需求：让鸭子能飞；
- 解法 1：使用继承：让超类 Duck 加上 fly() 方法（继承）；
  - 引发的问题：导致橡胶鸭子也会飞了（影响了不该有的类）；
  - 想改进它：覆盖（重写）橡胶鸭子的 fly() 方法，变成什么也不做；OK 的；
  - 但是又有下一个问题：又加入诱饵鸭，不会飞也不会叫，又要覆盖；
- 解法 2：利用接口（不使用继承）：设计 Flyable、Quackable，让”某些“（而不是全部）鸭子类型可飞可叫；
  - 引发的问题：代码无法复用（之前 Java 的接口不具有实现代码）；（Java 8 可以有默认实现，关键字 default）；（如果有三组飞行方式，也可以使用接口继承来做到，然后让子类鸭子再 implements，Java8 之后，感觉这就是接口的组合，这个设计模式感觉忽然没有了用武之地）；

## 1. 观察者模式：让你的对象知悉情况

## 2. 装饰者模式：装饰对象

## 3. 工厂模式：烘烤 OO 的精华

## 4. 单例模式：独一无二的对象

## 5. 命令模式：封装调用

## 6. 适配器模式、外观模式：随遇而安

## 7. 模板方法模式：封装算法

## 8. 迭代器与组合模式：管理良好的集合

## 9. 状态模式：事物的状态

## 10. 代理模式：控制对象访问

## 复合模式：多模式的联合使用

## 剩余的模式

### 桥接

### 生成器

### 责任链

### 蝇量

### 解释器

### 中介者

### 备忘录

### 原型

### 访问者