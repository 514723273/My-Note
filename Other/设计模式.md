## 0 基础

### 0.1 面向对象

- 封装
- 继承
- 多态

### 0.2 五大设计原则

1. S - 单一职责原则（The Single-Responsibility Principle）
    - 一个程序只做好一件事
    - 如果功能过于复杂就拆分开，每个部分保持独立
2. O - 开放封闭原则（The Open/Closed Principle）（软件设计的终极目标）
    - 对扩展开放，对修改封闭
    - 增加需求时，扩展型代码，而不是修改已有代码
3. L - 里氏置换原则（The Liskov Substitution Principle）（sʌbstɪ'tuʃ(ə)n）
   - 子类能覆盖父类
   - 父类能出现的地方，子类就能出现
4. I - 接口独立原则（The Interface Segregation Principle）（seɡrɪˈɡeɪʃn）
    - 保持结构的单一独立，避免出现“胖接口”
    - JS 中没有接口（typescript 例外），使用较少
    - 类似于单一职责原则，这里更关注接口
5. D - 依赖倒置原则（The Dependency-Inversion Principle）
    - 面向接口编程，依赖于抽象而不依赖于具体
    - 使用方只关注接口而不关注具体类的实现


在 JS 中（弱类型&继承使用较少）， S O 体现较多， L I D 体现较少。

#### 0.3 介绍 23 种设计模式

- 创建型
    1. 工厂模式（工厂方法模式、抽象工厂模式、建造者模式）（Factory）
    2. 单例模式（Singleton）
    3. 原型模式
- 结构型
    4. 适配器模式（Adapter）
    5. 装饰器模式（Decorator）
    6. 代理模式（Proxy）
    7. 外观模式（Facade）
    8. 桥接模式
    9. 组合模式
    10. 享元模式
- 行为型
    11. 策略模式
    12. 模板方法模式
    13. 观察者模式
    14. 迭代器模式
    15. 责任链模式
    16. 命令模式
    17. 备忘录模式
    18. 状态模式
    19. 访问者模式
    20. 中介者模式
    21. 解释器模式

## 1 工厂模式

- 将 new 操作单独封装
- 遇到 new 时，就要考虑是否该使用工厂模式

![工厂模式](https://raw.githubusercontent.com/514723273/.md-Pictures/master/工厂模式.png)

```js
class Product {
    constructor(name) {
        this.name = name;
    }
    init() {
        alert('init');
    }
    fun1() {
        alert('fun1');
    }
    fun2() {
        alert('fun2');
    }
}

class Creator {
    create(name) {
        return new Product();
    }
}

// test
const creator = new Creator();
const product = creator.create("my_product");
product.init();
product.fun1();
```

场景：jQuery、React.createElement、Vue 异步组件

## 2 单例模式

- 系统中被唯一使用
- 一个类只有一个实例

```js
class SingleObject {
    login() {
        console.log('login...');
    }
}

SingleObject.getInstance = (function() {
    let instance;
    return function() {
        if(instance == null) {
            instance = new SingleObject();
        }
        return instance;
    }
})();       // 闭包

const obj1 = SingleObject.getInstance();
obj1.login();
const obj2 = SingleObject.getInstance();
obj2.login();

console.log('obj1 === obj2', obj1 === obj2);        // true

// js中无法简单控制
const obj3 = new SingleObject();
obj3.login();   
console.log('obj1 === obj3', obj1 === obj3);        // false

```

场景：jQuery只有一个$、登陆框模拟、购物车、redux 中的 store
```js
// 1. jQuery只有一个$
if(window.jQuery != null) {
    return window.jQuery;
} else {
    // 初始化...
}

//2. 登陆框模拟
class LoginForm {
    constructor() {
        this.state = 'hide';
    }
    show() {
        if(this.state === 'show') {
            alert('已经显示');
            return;
        }
        this.state = 'show';
        console.log('登陆框显示成功');
    }
    hide() {
        if(this.state === 'hide') {
            alert('已隐藏');
            return;
        }
        this.state = 'hide';
        console.log('登陆框隐藏成功');
    }
}

LoginForm.getInstance = function() {
    let instance;

    return function() {
        if(instance == null) {
            instance = new LoginForm;
        }
        return instance;
    }
}();

const loginForm1 = new LoginForm();
loginForm1.show();
const loginForm2 = new LoginForm();
loginForm2.show();
loginForm2.hide();
console.log(loginForm1 === loginForm2);
```

## 3 适配器模式

- 旧接口格式和使用者不兼容
- 中间加一个适配器转换接口

```js
// 需要被适配的
class Adaptee {
    specificRequest() {
        return '德国标准的插头';
    }
}

// 适配器
class Target {
    constructor() {
        this.adaptee = new Adaptee();
    }
    request() {
        const info = this.adaptee.specificRequest();
        return `${info} -> 转换器 -> 中国标准的插头`;
    }
}

// 测试
const target = new Target();
console.log(target.request());
```

场景：封装旧接口、vue computed

## 4 装饰器模式

- 为对象添加新功能
- 不改变其原有的结构和功能

手机壳就是一个装饰器，保证手机正常工作的情况下（上网、电话，也不遮住摄像头和按钮），提供保护的功能。

```js
class Circle {
    draw() {
        console.log("画一个圆形");
    }
}

// 装饰器
class Decorator {
    constructor(circle) {
        this.circle = circle;
    }

    setRedColor() {
        console.log("将画笔设置为红色");
    }

    draw() {
        this.setRedColor();
        this.circle.draw();
    }
}

// test
const circle = new Circle();
circle.draw();

const decorator = new Decorator(circle);
decorator.draw();
```

场景：ES7 装饰器、core-decorators 库、 

```js
/**
* ES7 装饰器语法
**/
function testDec(isDec) {
    return function(target) {   // 最后一定是返回一个函数的
        target.isDec = isDec;
    }
}

@testDec(true)
class Demo {

}

console.log(Demo.isDec);    // true

/**
* mixins 举例
* 就是将其他对象的所有方法和属性，赋值到该类上
**/
function mixins(...list) {
    return function(target) {
        return Object.assign(target.prototype, ...list);
    }
}

const Foo = {
    foo() {
        alert('foo');
    }
}

@minxins(Foo)
class MyClass {

}

let obj = new MyClass();
obj.foo();
```

## 5 代理模式

```js
class RealImg {
    constructor(fileName) {
        this.fileName = fileName;
        this.loadFromDisk();        // 模拟初始化从硬盘读入
    }

    display() {
        console.log('display... ' + this.fileName);
    }

    loadFromDisk() {
        console.log('loading... ' + this.fileName);
    }
}

class ProxyImg {
    constructor(fileName) {
        this.realImg = new RealImg(fileName);
    }
    display() {
        this.realImg.display();
    }
}
```

场景：网页事件代理、jQuery $.proxy 、ES6 Proxy

```js
const star = {
    name: 'Kiyonami',
    age: 25,
    phone: 'star: 123456',
};

const agent = new Proxy(star, {
    get: function(target, key) {        // target 指向 star
        if(key === 'phone') {
            return 'agent: 666666';            // 经纪人不可能真的把明星的电话直接给出来吧。给经纪人自己的。
        }
        if(key === 'price') {
            return 120000;              // 明星不谈价格，经纪人来谈。
        }
        return target[key];             // 其他情况就直接返回了。（比如你想知道该明星的名字和年龄）
    },
    set: function(target, key, value) {
        if(key === 'customPrice') {     // 想来和经济人谈价格
            if(val < 100000) {
                throw new Error('价格太低');    // 经纪人的反馈
            } else {
                target[key] = value;
                return true;           // !!! 必须 return true 不然不会赋值
            }
        }
    }
});

console.log(agent.name);
console.log(agent.age);
console.log(agent.phone);
console.log(agent.price);
agent.customPrice = 130000;
```

- 适配器模式：提供一个不同的接口；代理模式：提供一模一样的接口。
- 装饰器模式：扩展功能，原有功能不变且可以直接使用；代理模式：显示原有功能，但是经过限制或者阉割。

## 6 外观模式

为子系统中的一组接口提供了一个高层接口，使用者使用这个高层接口。（其实不太符合接口独立原则（集合了），谨慎使用）

场景：
```js
// 相当于高层接口
function bindEvent(elem, type, selector, fn) {
    // 兼容 4 个参数，或者 3 个参数
    if(fn == null) {
        fn = selector;
        selector = null;
    } 
    // ...
}

// 调用两个子函数
bindEvent(elem, 'click', "#div1", fn);
bindEvent(elem, 'click', fn);
```

## 7 观察者模式

发布&订阅；一对多


![js设计模式-观察者模式](https://raw.githubusercontent.com/514723273/.md-Pictures/master/js设计模式-观察者模式.png)

```js
class Subject {
    constructor() {
        this.state = 0;
        this.observers = [];
    }
    getState() {
        return this.state;
    }
    setState(state) {
        this.state = state;
        this.notifyAllObservers();      // {!!!} 关键点！就是在主题状态变化的时候，通知所有观察者改变
    }
    notifyAllObservers() {              // 遍历通知
        this.observers.forEach(observer => {
            observer.update();
        })
    }
    register(observer) {                // 注册
        this.observers.push(observer);
    }
}

class Observer {
    constructor(testName, subject) {
        this.testName = testName;
        this.subject = subject;
        this.subject.register(this);    // 内部注册
    }

    update() {      // 所有的观察者必须有 update 方法（接口
        console.log(`${this.testName} update: subject state is ${this.subject.state}`);
    }
}

const subject = new Subject();

const observer1 = new Observer('111', subject);
const observer2 = new Observer('222', subject);
const observer3 = new Observer('333', subject);

subject.setState(1);
```

场景：网页事件绑定、Promise、jQuery cllbacks、nodejs 自定义事件、nodejs 处理 http 请求、Vue 和 React 组件生命周期触发
