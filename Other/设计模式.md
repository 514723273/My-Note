## 0 基础

### 0.1 面向对象

- 封装
- 继承
- 多态

### 0.2 五大设计原则

1. S - 单一职责原则（The Single-Responsibility Principle）
    - 一个程序只做好一件事
    - 如果功能过于复杂就拆分开，每个部分保持独立
2. O - 开放封闭原则（The Open/Closed Principle）（软件设计的终极目标）
    - 对扩展开放，对修改封闭
    - 增加需求时，扩展型代码，而不是修改已有代码
3. L - 里氏置换原则（The Liskov Substitution Principle）（sʌbstɪ'tuʃ(ə)n）
   - 子类能覆盖父类
   - 父类能出现的地方，子类就能出现
4. I - 接口独立原则（The Interface Segregation Principle）（seɡrɪˈɡeɪʃn）
    - 保持结构的单一独立，避免出现“胖接口”
    - JS 中没有接口（typescript 例外），使用较少
    - 类似于单一职责原则，这里更关注接口
5. D - 依赖倒置原则（The Dependency-Inversion Principle）
    - 面向接口编程，依赖于抽象而不依赖于具体
    - 使用方只关注接口而不关注具体类的实现


在 JS 中（弱类型&继承使用较少）， S O 体现较多， L I D 体现较少。

#### 0.3 介绍 23 种设计模式

- 创建型
    1. 工厂模式（工厂方法模式、抽象工厂模式、建造者模式）（Factory）
    2. 单例模式（Singleton）
    3. 原型模式
- 结构型
    4. 适配器模式（Adapter）
    5. 装饰器模式（Decorator）
    6. 代理模式
    7. 外观模式
    8. 桥接模式
    9. 组合模式
    10. 享元模式
- 行为型
    11. 策略模式
    12. 模板方法模式
    13. 观察者模式
    14. 迭代器模式
    15. 责任链模式
    16. 命令模式
    17. 备忘录模式
    18. 状态模式
    19. 访问者模式
    20. 中介者模式
    21. 解释器模式

## 1 工厂模式

- 将 new 操作单独封装
- 遇到 new 时，就要考虑是否该使用工厂模式

![工厂模式](https://raw.githubusercontent.com/514723273/.md-Pictures/master/工厂模式.png)

```js
class Product {
    constructor(name) {
        this.name = name;
    }
    init() {
        alert('init');
    }
    fun1() {
        alert('fun1');
    }
    fun2() {
        alert('fun2');
    }
}

class Creator {
    create(name) {
        return new Product();
    }
}

// test
const creator = new Creator();
const product = creator.create("my_product");
product.init();
product.fun1();
```

场景：jQuery、React.createElement、Vue 异步组件

## 2 单例模式

- 系统中被唯一使用
- 一个类只有一个实例

```js
class SingleObject {
    login() {
        console.log('login...');
    }
}

SingleObject.getInstance = (function() {
    let instance;
    return function() {
        if(instance == null) {
            instance = new SingleObject();
        }
        return instance;
    }
})();       // 闭包

const obj1 = SingleObject.getInstance();
obj1.login();
const obj2 = SingleObject.getInstance();
obj2.login();

console.log('obj1 === obj2', obj1 === obj2);        // true

// js中无法简单控制
const obj3 = new SingleObject();
obj3.login();   
console.log('obj1 === obj3', obj1 === obj3);        // false

```

场景：jQuery只有一个$、登陆框模拟、购物车、redux 中的 store
```js
// 1. jQuery只有一个$
if(window.jQuery != null) {
    return window.jQuery;
} else {
    // 初始化...
}

//2. 登陆框模拟
class LoginForm {
    constructor() {
        this.state = 'hide';
    }
    show() {
        if(this.state === 'show') {
            alert('已经显示');
            return;
        }
        this.state = 'show';
        console.log('登陆框显示成功');
    }
    hide() {
        if(this.state === 'hide') {
            alert('已隐藏');
            return;
        }
        this.state = 'hide';
        console.log('登陆框隐藏成功');
    }
}

LoginForm.getInstance = function() {
    let instance;

    return function() {
        if(instance == null) {
            instance = new LoginForm;
        }
        return instance;
    }
}();

const loginForm1 = new LoginForm();
loginForm1.show();
const loginForm2 = new LoginForm();
loginForm2.show();
loginForm2.hide();
console.log(loginForm1 === loginForm2);
```

## 3 适配器模式

- 旧接口格式和使用者不兼容
- 中间加一个适配器转换接口

```js
// 需要被适配的
class Adaptee {
    specificRequest() {
        return '德国标准的插头';
    }
}

// 适配器
class Target {
    constructor() {
        this.adaptee = new Adaptee();
    }
    request() {
        const info = this.adaptee.specificRequest();
        return `${info} -> 转换器 -> 中国标准的插头`;
    }
}

// 测试
const target = new Target();
console.log(target.request());
```

场景：封装旧接口、vue computed

## 4 装饰器模式

- 为对象添加新功能
- 不改变其原有的结构和功能

手机壳就是一个装饰器，保证手机正常工作的情况下（上网、电话，也不遮住摄像头和按钮），提供保护的功能。

```js
class Circle {
    draw() {
        console.log("画一个圆形");
    }
}

// 装饰器
class Decorator {
    constructor(circle) {
        this.circle = circle;
    }

    setRedColor() {
        console.log("将画笔设置为红色");
    }

    draw() {
        this.setRedColor();
        this.circle.draw();
    }
}

// test
const circle = new Circle();
circle.draw();

const decorator = new Decorator(circle);
decorator.draw();
```

场景：ES7 装饰器、core-decorators 库、 

```js
/**
* ES7 装饰器语法
**/
function testDec(isDec) {
    return function(target) {   // 最后一定是返回一个函数的
        target.isDec = isDec;
    }
}

@testDec(true)
class Demo {

}

console.log(Demo.isDec);    // true

/**
* mixins 举例
* 就是将其他对象的所有方法和属性，赋值到该类上
**/
function mixins(...list) {
    return function(target) {
        return Object.assign(target.prototype, ...list);
    }
}

const Foo = {
    foo() {
        alert('foo');
    }
}

@minxins(Foo)
class MyClass {

}

let obj = new MyClass();
obj.foo();
```